"""
Utility functions for the Observatory Configurator.
Handles .env file management, service control, and connection testing.
"""

import os
import re
import socket
import subprocess
from pathlib import Path
from typing import Any, Dict, Optional, Tuple

import requests

# Path to the collector's .env file (parent directory)
ENV_FILE = Path(__file__).parent.parent / ".env"

# Default configuration values
# Multi-device: up to 3 of each type (SQM, DAVIS, CLOUDWATCHER)
DEFAULTS = {
    "REMOTE_API_URL": "https://your-site.vercel.app/api/ingest",
    "API_KEY": "",
    "MQTT_BROKER": "localhost",
    "MQTT_PORT": "1883",
    # SQM devices (up to 3)
    "SQM_1_HOST": "",
    "SQM_1_PORT": "10001",
    "SQM_2_HOST": "",
    "SQM_2_PORT": "10001",
    "SQM_3_HOST": "",
    "SQM_3_PORT": "10001",
    # Davis WeatherLink devices (up to 3)
    "DAVIS_1_HOST": "",
    "DAVIS_1_INTERVAL": "30",
    "DAVIS_2_HOST": "",
    "DAVIS_2_INTERVAL": "30",
    "DAVIS_3_HOST": "",
    "DAVIS_3_INTERVAL": "30",
    # Cloudwatcher devices (up to 3)
    "CLOUDWATCHER_1_HOST": "",
    "CLOUDWATCHER_1_INTERVAL": "30",
    "CLOUDWATCHER_2_HOST": "",
    "CLOUDWATCHER_2_INTERVAL": "30",
    "CLOUDWATCHER_3_HOST": "",
    "CLOUDWATCHER_3_INTERVAL": "30",
    # AllSky
    "ALLSKY_IMAGE_PATH": "/home/pi/allsky/tmp/image.jpg",
    "ALLSKY_IMAGE_URL": "",
    # General
    "PUSH_INTERVAL": "60",
    "BOM_SATELLITE_ENABLED": "true",
    "BOM_SATELLITE_INTERVAL": "600",
    "BOM_RADAR_STATION": "",
    "LOG_LEVEL": "INFO",
    # Legacy MQTT codes
    "INSTRUMENT_CODE_MQTT_WEATHER": "wx-mqtt",
    "INSTRUMENT_CODE_ALLSKY": "allsky-main",
}

# BOM Radar stations (common ones)
BOM_RADAR_STATIONS = {
    "02": "Melbourne",
    "03": "Wollongong",
    "04": "Newcastle",
    "08": "Canberra",
    "17": "Hobart",
    "19": "Cairns",
    "23": "Gladstone",
    "24": "Mackay",
    "28": "Townsville",
    "29": "Broome",
    "40": "Darwin",
    "41": "Mt Isa",
    "44": "Albany",
    "46": "Geraldton",
    "48": "Kalgoorlie",
    "50": "Esperance",
    "64": "Adelaide",
    "66": "Brisbane",
    "68": "Mildura",
    "69": "Wagga Wagga",
    "70": "Perth",
    "71": "Sydney",
    "72": "Emerald",
    "73": "Moree",
    "75": "Weipa",
    "76": "Mount Gambier",
    "77": "Alice Springs",
}


def load_env() -> Dict[str, str]:
    """Load configuration from .env file."""
    config = DEFAULTS.copy()

    if ENV_FILE.exists():
        with open(ENV_FILE, "r") as f:
            for line in f:
                line = line.strip()
                # Skip comments and empty lines
                if not line or line.startswith("#"):
                    continue
                # Parse KEY=VALUE
                match = re.match(r'^([A-Z_][A-Z0-9_]*)=(.*)$', line)
                if match:
                    key, value = match.groups()
                    # Remove quotes if present
                    value = value.strip('"\'')
                    config[key] = value

    return config


def save_env(config: Dict[str, str]) -> bool:
    """Save configuration to .env file."""
    try:
        lines = [
            "# Observatory Collector Configuration",
            "# Generated by Observatory Configurator",
            "",
            "# API Connection",
            f'REMOTE_API_URL={config.get("REMOTE_API_URL", "")}',
            f'API_KEY={config.get("API_KEY", "")}',
            "",
            "# MQTT Broker",
            f'MQTT_BROKER={config.get("MQTT_BROKER", "localhost")}',
            f'MQTT_PORT={config.get("MQTT_PORT", "1883")}',
            "",
            "# =============================================================================",
            "# MULTI-INSTRUMENT CONFIGURATION",
            "# Each instrument type supports up to 3 devices.",
            "# Leave HOST empty to disable that slot.",
            "# Instrument codes are auto-generated from serial numbers when available.",
            "# =============================================================================",
            "",
            "# SQM-LE Devices (up to 3)",
            f'SQM_1_HOST={config.get("SQM_1_HOST", "")}',
            f'SQM_1_PORT={config.get("SQM_1_PORT", "10001")}',
            "",
            f'SQM_2_HOST={config.get("SQM_2_HOST", "")}',
            f'SQM_2_PORT={config.get("SQM_2_PORT", "10001")}',
            "",
            f'SQM_3_HOST={config.get("SQM_3_HOST", "")}',
            f'SQM_3_PORT={config.get("SQM_3_PORT", "10001")}',
            "",
            "# Davis WeatherLink Live Devices (up to 3)",
            f'DAVIS_1_HOST={config.get("DAVIS_1_HOST", "")}',
            f'DAVIS_1_INTERVAL={config.get("DAVIS_1_INTERVAL", "30")}',
            "",
            f'DAVIS_2_HOST={config.get("DAVIS_2_HOST", "")}',
            f'DAVIS_2_INTERVAL={config.get("DAVIS_2_INTERVAL", "30")}',
            "",
            f'DAVIS_3_HOST={config.get("DAVIS_3_HOST", "")}',
            f'DAVIS_3_INTERVAL={config.get("DAVIS_3_INTERVAL", "30")}',
            "",
            "# AAG Cloudwatcher Devices (up to 3)",
            f'CLOUDWATCHER_1_HOST={config.get("CLOUDWATCHER_1_HOST", "")}',
            f'CLOUDWATCHER_1_INTERVAL={config.get("CLOUDWATCHER_1_INTERVAL", "30")}',
            "",
            f'CLOUDWATCHER_2_HOST={config.get("CLOUDWATCHER_2_HOST", "")}',
            f'CLOUDWATCHER_2_INTERVAL={config.get("CLOUDWATCHER_2_INTERVAL", "30")}',
            "",
            f'CLOUDWATCHER_3_HOST={config.get("CLOUDWATCHER_3_HOST", "")}',
            f'CLOUDWATCHER_3_INTERVAL={config.get("CLOUDWATCHER_3_INTERVAL", "30")}',
            "",
            "# AllSky Camera",
            f'ALLSKY_IMAGE_PATH={config.get("ALLSKY_IMAGE_PATH", "")}',
            f'ALLSKY_IMAGE_URL={config.get("ALLSKY_IMAGE_URL", "")}',
            "",
            "# Data Push",
            f'PUSH_INTERVAL={config.get("PUSH_INTERVAL", "60")}',
            "",
            "# BOM Satellite & Radar",
            f'BOM_SATELLITE_ENABLED={config.get("BOM_SATELLITE_ENABLED", "true")}',
            f'BOM_SATELLITE_INTERVAL={config.get("BOM_SATELLITE_INTERVAL", "600")}',
            f'BOM_RADAR_STATION={config.get("BOM_RADAR_STATION", "")}',
            "",
            "# Logging",
            f'LOG_LEVEL={config.get("LOG_LEVEL", "INFO")}',
            "",
            "# Legacy Instrument Codes (for MQTT sources)",
            f'INSTRUMENT_CODE_MQTT_WEATHER={config.get("INSTRUMENT_CODE_MQTT_WEATHER", "wx-mqtt")}',
            f'INSTRUMENT_CODE_ALLSKY={config.get("INSTRUMENT_CODE_ALLSKY", "allsky-main")}',
            "",
        ]

        with open(ENV_FILE, "w") as f:
            f.write("\n".join(lines))

        return True
    except Exception as e:
        print(f"Error saving config: {e}")
        return False


def mask_api_key(key: str) -> str:
    """Mask API key for display, showing only last 4 characters."""
    if not key or len(key) < 8:
        return "****"
    return f"****{key[-4:]}"


def get_service_status() -> Dict[str, Any]:
    """Get the status of the observatory-collector service."""
    result = {
        "running": False,
        "enabled": False,
        "uptime": None,
        "error": None,
    }

    try:
        # Check if service is active
        proc = subprocess.run(
            ["systemctl", "is-active", "observatory-collector"],
            capture_output=True,
            text=True,
        )
        result["running"] = proc.stdout.strip() == "active"

        # Check if service is enabled
        proc = subprocess.run(
            ["systemctl", "is-enabled", "observatory-collector"],
            capture_output=True,
            text=True,
        )
        result["enabled"] = proc.stdout.strip() == "enabled"

        # Get uptime if running
        if result["running"]:
            proc = subprocess.run(
                ["systemctl", "show", "observatory-collector", "--property=ActiveEnterTimestamp"],
                capture_output=True,
                text=True,
            )
            timestamp = proc.stdout.strip().split("=")[1] if "=" in proc.stdout else None
            result["uptime"] = timestamp

    except FileNotFoundError:
        result["error"] = "systemctl not found - not running on Linux?"
    except Exception as e:
        result["error"] = str(e)

    return result


def control_service(action: str) -> Tuple[bool, str]:
    """Start, stop, or restart the observatory-collector service."""
    if action not in ("start", "stop", "restart"):
        return False, f"Invalid action: {action}"

    try:
        proc = subprocess.run(
            ["sudo", "systemctl", action, "observatory-collector"],
            capture_output=True,
            text=True,
            timeout=30,
        )

        if proc.returncode == 0:
            return True, f"Service {action} successful"
        else:
            return False, proc.stderr or f"Failed to {action} service"

    except subprocess.TimeoutExpired:
        return False, f"Timeout waiting for service {action}"
    except FileNotFoundError:
        return False, "systemctl not found"
    except Exception as e:
        return False, str(e)


def get_logs(lines: int = 100, level: Optional[str] = None) -> list:
    """Get recent log entries from journalctl."""
    try:
        cmd = ["journalctl", "-u", "observatory-collector", "-n", str(lines), "--no-pager", "-o", "short-iso"]

        proc = subprocess.run(cmd, capture_output=True, text=True, timeout=10)

        log_lines = proc.stdout.strip().split("\n") if proc.stdout else []

        # Filter by level if specified
        if level and level != "ALL":
            level_upper = level.upper()
            log_lines = [l for l in log_lines if level_upper in l.upper()]

        return log_lines

    except Exception as e:
        return [f"Error fetching logs: {e}"]


def test_api_connection(url: str, api_key: str) -> Tuple[bool, str, Optional[Dict]]:
    """Test connection to the Vercel API."""
    try:
        # Test the /api/current endpoint (read-only, no auth needed)
        base_url = url.replace("/api/ingest", "")
        test_url = f"{base_url}/api/current"

        response = requests.get(test_url, timeout=10)

        if response.ok:
            data = response.json()
            return True, "Connected successfully", data
        else:
            return False, f"HTTP {response.status_code}: {response.text[:100]}", None

    except requests.exceptions.ConnectionError:
        return False, "Connection failed - check URL", None
    except requests.exceptions.Timeout:
        return False, "Connection timed out", None
    except Exception as e:
        return False, str(e), None


def test_sqm_connection(host: str, port: int = 10001) -> Tuple[bool, str, Optional[Dict]]:
    """Test connection to SQM-LE device."""
    if not host:
        return False, "No host configured", None

    try:
        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as sock:
            sock.settimeout(10)
            sock.connect((host, port))

            # Send reading request
            sock.sendall(b"rx")

            # Wait for response
            import time
            time.sleep(0.5)

            response = b""
            while not response.endswith(b"\n"):
                chunk = sock.recv(256)
                if not chunk:
                    break
                response += chunk

            response_str = response.decode("ascii", errors="ignore").strip()

            if response_str.startswith("r,"):
                parts = response_str.split(",")
                if len(parts) >= 2:
                    mag_str = parts[1].strip()
                    sqm_value = float(mag_str.replace("m", "").strip())

                    sqm_temp = None
                    if len(parts) >= 5:
                        temp_str = parts[4].strip()
                        if temp_str.endswith("C"):
                            sqm_temp = float(temp_str.replace("C", "").strip())

                    return True, "Connected", {
                        "sky_quality": sqm_value,
                        "temperature": sqm_temp,
                        "raw": response_str,
                    }

            return False, f"Unexpected response: {response_str[:50]}", None

    except socket.timeout:
        return False, "Connection timed out", None
    except ConnectionRefusedError:
        return False, "Connection refused", None
    except Exception as e:
        return False, str(e), None


def test_weatherlink_connection(host: str) -> Tuple[bool, str, Optional[Dict]]:
    """Test connection to WeatherLink Live device."""
    if not host:
        return False, "No host configured", None

    try:
        url = f"http://{host}/v1/current_conditions"
        response = requests.get(url, timeout=10)

        if response.ok:
            data = response.json()

            if data.get("error"):
                return False, f"Device error: {data['error']}", None

            conditions = data.get("data", {}).get("conditions", [])

            # Extract key values
            result = {}
            for condition in conditions:
                data_type = condition.get("data_structure_type")
                if data_type == 1:  # ISS
                    if condition.get("temp") is not None:
                        result["temperature_f"] = condition["temp"]
                        result["temperature_c"] = round((condition["temp"] - 32) * 5 / 9, 1)
                    if condition.get("hum") is not None:
                        result["humidity"] = condition["hum"]
                elif data_type == 3:  # Barometer
                    if condition.get("bar_sea_level") is not None:
                        result["pressure_inhg"] = condition["bar_sea_level"]
                        result["pressure_hpa"] = round(condition["bar_sea_level"] * 33.8639, 1)

            return True, "Connected", result
        else:
            return False, f"HTTP {response.status_code}", None

    except requests.exceptions.ConnectionError:
        return False, "Connection failed", None
    except requests.exceptions.Timeout:
        return False, "Connection timed out", None
    except Exception as e:
        return False, str(e), None


def test_cloudwatcher_connection(host: str) -> Tuple[bool, str, Optional[Dict]]:
    """Test connection to AAG Cloudwatcher CGI interface."""
    if not host:
        return False, "No host configured", None

    try:
        url = f"http://{host}/cgi-bin/cgiLastData"
        response = requests.get(url, timeout=10)

        if response.ok:
            # Parse key=value format
            data = {}
            for line in response.text.strip().split("\n"):
                if "=" in line:
                    key, value = line.split("=", 1)
                    data[key.strip()] = value.strip()

            result = {
                "sky_temp": float(data.get("clouds", 0)) if "clouds" in data else None,
                "ambient_temp": float(data.get("temp", 0)) if "temp" in data else None,
                "cloud_safe": data.get("cloudsSafe") == "1",
                "rain_safe": data.get("rainSafe") == "1",
                "wind_safe": data.get("windSafe") == "1",
                "light_safe": data.get("lightSafe") == "1",
            }

            return True, "Connected", result
        else:
            return False, f"HTTP {response.status_code}", None

    except requests.exceptions.ConnectionError:
        return False, "Connection failed", None
    except requests.exceptions.Timeout:
        return False, "Connection timed out", None
    except Exception as e:
        return False, str(e), None


def test_allsky_image(path: str = None, url: str = None) -> Tuple[bool, str, Optional[str]]:
    """Test AllSky image availability."""
    # Try local file first
    if path:
        file_path = Path(path)
        if file_path.exists():
            import time
            age = time.time() - file_path.stat().st_mtime
            if age < 300:
                return True, f"File available (age: {int(age)}s)", str(file_path)
            else:
                return False, f"File too old ({int(age)}s)", None

    # Try URL
    if url:
        try:
            response = requests.head(url, timeout=10)
            if response.ok:
                return True, "URL accessible", url
            else:
                return False, f"URL returned {response.status_code}", None
        except Exception as e:
            return False, str(e), None

    return False, "No path or URL configured", None
